module multStage (opN, operated, extra, out);
	input [31:0] opN;
	input [63:0] operated;
	input extra;
	output [63:0] out;

	wire [31:0] Val;
	
	wire [2:0]c1;
	//constructs 8+1 bit array for Booth's to iterate over.
	assign c1[0] = extra;
	assign c1[1] = operated[0];
	assign c1[2] = operated[1];
	
	wire contOneTwo, contDoSth, AddOrSub;
	//the lines below are based the opcode for the adder:
		// 0xx -> do nothing
		// 11x -> use add, 10x use subtract
		// 1x1 -> use shifted number, 1x0 -> use regular number
	assign contDoSth = (~c1[2] & c1[1] & c1[0] )| (c1[2] & ~c1[1] & ~c1[0]);
	assign addOrSub =  c1[2];
	assign contOneTwo = ~((c1[2] & c1[1] & c1[0]) |(~c1[2] & ~c1[1] & ~c1[0]));
	oneAddShift oneAdd(.addend(Val), .largeNum(operated), .ctrl(AddOrSub), .out(out));
	
	genvar i;
	generate
	for (i = 0; i < 32; i = i + 1) begin: doNothing
			TRI doNothing(.in('b0), .out(Val[i]), .oe(~contDoSth));
	end
	for (i = 1; i < 31; i = i + 1) begin: loop2
			TRI OnceSum(.in(opN[i]),.out(Val[i]), .oe(~contOneTwo));
			TRI TwiceSum(.in(opN[i-1]),.out(Val[i]), .oe(contOneTwo));
	end
			TRI OnceSumF(.in(opN[0]),.out(Val[i]), .oe(~contOneTwo));
			TRI TwiceSumF(.in('1b0),.out(Val[i]), .oe(contOneTwo));
			TRI OnceSumL(.in(opN[31]),.out(Val[i]), .oe(~contOneTwo));
			TRI TwiceSumL(.in(opN[30]),.out(Val[i]), .oe(contOneTwo));
	endgenerate
endmodule

module oneAddShift(addend, largeNum, ctrl, out);
	input [31:0] addend;
	input [63:0] largeNum;
	input ctrl;
	output [63:0]out;
	
	//addOrSub
	wire [31:0] tempRes;
	wire [31:0] toAdder;
	wire [63:0] AddRes;
	wire [31:0] partWeAdd;
	generate
		for (i = 0; i < 32; i = i + 1)begin: loop98
			assign partWeAdd[i] = largeNum[i+32];
			assign toAdder[i] = (~addend[i])&(~ctrl)|(addend[i])&ctrl;
		end
	endgenerate
	Adder addsub(.A(partWeAdd), .B(toAdder), .Cin(ctrl), .out(tempRes))
	//assign tempRes = partWeAdd+toAdder;
	generate
		for (i= 0; i < 32; i = i + 1) begin: loop1
			assign AddRes[i] = largeNum[i];
			assign AddRes[i+32] = tempRes[i];
		end
	endgenerate
	//do or nothing
	wire [63:0] temp;
	generate
		for (i= 0; i < 64; i = i + 1) begin: loop2
				tri_buf meTri1(.a(AddRes[i]), .b(temp[i]), .enable(ctrl[2]));
				tri_buf meTri2(.a(largeNum[i]), .b(temp[i]), .enable(~ctrl[2]));
		end
	endgenerate
	//shift by Two
	twoShiftR myShift(.A(temp), .out(out));
endmodule

module twoShiftR(A, out);
	input [63:0]A;
	output [63:0]out;

	genvar i;
	generate
		for (i = 0; i < 62; i = i + 1) begin: loop1
		assign out[i] = A[i+2];
		end
	endgenerate
	assign out[62] = out[61];
	assign out[63] = out[61];
endmodule
